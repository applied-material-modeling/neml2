<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.16.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NEML2: Model</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
window.MathJax = {
  loader: {load: ['[tex]/ams', '[tex]/physics', '[tex]/boldsymbol']},
  tex: {packages: {'[+]': ['ams', 'physics', 'boldsymbol']},
        tags: 'ams'}
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-tabs.js" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <!-- Demo animations -->
  <script type="text/javascript" src="anime.min.js"></script>
  <script type="text/javascript" src="work-dispatcher.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler.js"></script>
  <script type="text/javascript" src="simple-scheduler-demo.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler-demo.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init();
    DoxygenAwesomeParagraphLink.init();
    DoxygenAwesomeInteractiveToc.init();
    DoxygenAwesomeTabs.init();
    SimpleSchedulerDemo.init();
    StaticHybridSchedulerDemo.init();
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">NEML2<span
                    id="projectnumber">&#160;2.0.0</span>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('system-models.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Model </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_build_2doc_2content_2system_2model"></a></p>
<p>Refer to <a class="el" href="syntax-models.html" title="[Models]">Syntax Documentation</a> for the list of available objects.</p>
<h1 class="doxsection"><a class="anchor" id="model-definition"></a>
Model definition</h1>
<p>A NEML2 model is a function (in the context of mathematics)   </p><p class="formulaDsp">
\[  f: \mathbb{R}^m \to \mathbb{R}^n
\]
</p>
<p> mapping from the input space \(\mathbb{R}^m\) of dimension \(m\) to the output space \(\mathbb{R}^n\) of dimension \(n\). \(\left[ \cdot \right]\) be the flatten-concatenation operator, the input vector is the concatenation of \(p\) flattened variables, i.e.,   </p><p class="formulaDsp">
\[  x = \left[ x_i \right]_{i=1}^p \in \mathbb{R}^m, \quad \sum_{i=1}^p \lvert x_i \rvert = m,
\]
</p>
<p> where \(\lvert x \rvert\) denotes the modulus of flattened variable \(x\). Similarly, the output vector is the concatenation of \(q\) flattened variables, i.e.,   </p><p class="formulaDsp">
\[  y = \left[ y_i \right]_{i=1}^q \in \mathbb{R}^n, \quad \sum_{i=1}^q \lvert y_i \rvert = n.
\]
</p>
<p>Translating the above mathematical definition into NEML2 is straightforward.</p><ul>
<li>A model following this definition derives from <a class="el" href="classneml2_1_1Model.html" title="Model">Model</a>.</li>
<li><a class="el" href="classneml2_1_1VariableStore.html#abe525f0612ff23024cfabe6aab5ad131" title="declare_input_variable">declare_input_variable</a> declares an input variable \(x_i\) in the input space \(\mathbb{R}^m\).</li>
<li><a class="el" href="classneml2_1_1VariableStore.html#a6a9254a07912357e3d148a7d37a21eb6" title="declare_output_variable">declare_output_variable</a> declares an output variable \(y_i\) in the output space \(\mathbb{R}^n\).</li>
<li><a class="el" href="classneml2_1_1Model.html#a6a028925dc10166ea6426fc4d7635ad2" title="set_value">set_value</a> is a method defining the forward operator \(f\) itself.</li>
</ul>
<p>Both <span class="tt">declare_input_variable</span> and <span class="tt">declare_output_variable</span> are templated on the variable type &ndash; recall that only a variable of the NEML2 primitive tensor type can be registered. Furthermore, both methods return a <span class="tt">Variable&lt;T&gt; &amp;</span> used for retrieving and setting the variable value inside the forward operator, i.e. <span class="tt">set_value</span>. Note that the reference returned by <span class="tt">declare_input_variable</span> is writable, while the reference returned by <span class="tt">declare_output_variable</span> is read-only.</p>
<h1 class="doxsection"><a class="anchor" id="model-composition"></a>
Model composition</h1>
<p>Quoting <a href="https://en.wikipedia.org/wiki/Function_composition">Wikipedia</a>: </p><blockquote class="doxtable">
<p>In mathematics, function composition is an operation \(\circ\) that takes two functions \(f\) and \(g\), and produces a function \(h = g \circ f\) such that \(h(x) = g(f(x))\). </p>
</blockquote>
<p>Since NEML2 <span class="tt">Model</span> is a function (in the context of mathematics) at its core, it should be possible, in theory, to compose different NEML2 <span class="tt">Model</span>s into a new NEML2 <span class="tt">Model</span>. The <a class="el" href="classneml2_1_1ComposedModel.html" title="ComposedModel">ComposedModel</a> is precisely for that purpose.</p>
<p>Similar to the statement "a composed function is a function" in the context of mathematics, in NEML2, the equivalent statement "a `ComposedModel` is a `Model`" also holds. In addition, the <span class="tt">ComposedModel</span> provides four key features to help simplify the composition and reduces computational cost:</p><ul>
<li>Automatic dependency registration</li>
<li>Automatic input/output identification</li>
<li>Automatic dependency resolution</li>
<li>Automatic chain rule</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="a-symbolic-example"></a>
A symbolic example</h2>
<p>To demonstrate the utility of the four key features of <span class="tt">ComposedModel</span>, let us consider the composition of three functions \(f\), \(g\), and \(h\):     </p><p class="formulaDsp">
\begin{align*}  y_1 &amp;= f(x_1, x_2), \\
  y_2 &amp;= g(y_1, x_3), \\
  y &amp;= h(y_1, y_2, x_4).
\end{align*}
</p>
<h2 class="doxsection"><a class="anchor" id="automatic-dependency-registration"></a>
Automatic dependency registration</h2>
<p>It is obvious to us that the function \(h\) <em>depends</em> on functions \(f\) and \(g\) because the input of \(h\) depends on the outputs of \(f\) and \(g\). Such dependency is automatically identified and registered while composing a <span class="tt">ComposedModel</span> in NEML2. This procedure is called "automatic dependency registration".</p>
<p>In order to identify dependencies among different <span class="tt">Model</span>s, we keep track of the set of <em>consumed</em> variables, \(\mathcal{I}_i\), and a set of <em>provided</em> variables, \(\mathcal{O}_i\), for each <span class="tt">Model</span> \(f_i\). When a set of models (functions) are composed together, <span class="tt">Model</span> \(f_i\) is said to <em>depend</em> on \(f_j\) if and only if \(\exists x\) such that   </p><p class="formulaDsp">
\[  x \in \mathcal{I}_i \wedge x \in \mathcal{O}_j.
\]
</p>
<h2 class="doxsection"><a class="anchor" id="automatic-input-output-identification"></a>
Automatic input/output identification</h2>
<p>The only possible composition \(r\) of these three functions is   </p><p class="formulaDsp">
\[  y = r(x_1, x_2, x_3, x_4) := h(f(x_1, x_2), g(f(x_1, x_2), x_3), x_4).
\]
</p>
<p> The input variables of the composed function \(r\) are \([x_1, x_2, x_3, x_4]\) (or their flattened concatenation), and the output variable of the composed function is simply \(y\). The input/output variables are automatically identified while composing a <span class="tt">ComposedModel</span> in NEML2. This procedure is referred to as "automatic input/output identification".</p>
<p>In a <span class="tt">ComposedModel</span>, a <em>leaf</em> model is a model which does not depend on any other model, and a <em>root</em> model is a model which is not depent upon by any other model. A <span class="tt">ComposedModel</span> may have multiple leaf models and multiple root models. An input variable is said to be a <em>root</em> input variable if it is not consumed by any other model, i.e. \(x \in \mathcal{I}_i\) is a root input variable if and only if   </p><p class="formulaDsp">
\[    x \notin \mathcal{O}_j, \quad \forall i \neq j.
\]
</p>
<p> Similarly, an output variable is said to be a <em>leaf</em> output variable if it is not provided by any other model, i.e. \(x \in \mathcal{O}_i\) is a leaf output variable if an only if   </p><p class="formulaDsp">
\[    x \notin \mathcal{I}_j, \quad \forall i \neq j.
\]
</p>
<p> The input variables of a <span class="tt">ComposedModel</span> is the union of the set of all the root input variables, and the output variables of a <span class="tt">ComposedModel</span> is the set of all the leaf output variables.</p>
<h2 class="doxsection"><a class="anchor" id="automatic-dependency-resolution"></a>
Automatic dependency resolution</h2>
<p>To evaluate the forward operator of the composed model \(r\), one has to first evaluate model \(f\), then model \(g\), and finally model \(h\). The process of sorting out such evaluation order is called "dependency resolution".</p>
<p>While it is possible to sort the evaluation order "by hand" for this simple example composition, it is generally not a trivial task for practical compositions with more involved dependencies. To that end, NEML2 uses <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> to sort the model evaluation order, such that by the time each model is evaluated, all of its dependent models have already been evaluated.</p>
<h2 class="doxsection"><a class="anchor" id="automatic-chain-rule"></a>
Automatic chain rule</h2>
<p>Chain rule can be applied to evaluate the derivative of the forward operator with respect to the input variables, i.e.,      </p><p class="formulaDsp">
\begin{align*}  \frac{\partial y}{\partial x_1} &amp;= \left( \frac{\partial y}{\partial y_1} + \frac{\partial y}{\partial y_2} \frac{\partial y_2}{\partial y_1} \right) \frac{\partial y_1}{\partial x_1}, \\
  \frac{\partial y}{\partial x_2} &amp;= \left( \frac{\partial y}{\partial y_1} + \frac{\partial y}{\partial y_2} \frac{\partial y_2}{\partial y_1} \right) \frac{\partial y_1}{\partial x_2}, \\
  \frac{\partial y}{\partial x_3} &amp;= \frac{\partial y}{\partial y_2} \frac{\partial y_2}{\partial x_3}, \\
  \frac{\partial y}{\partial x_4} &amp;= \frac{\partial y}{\partial x_4}.
\end{align*}
</p>
<p> Spelling out this chain rule can be cumbersome and error-prone, especially for more complicated model compositions. The evaluation of the chain rule is automated in NEML2, and the user is only responsible for implementing the partial derivatives of each model. For example, in the implementation of <span class="tt">Model</span> \(f\), the user only need to define the partial derivatives   </p><p class="formulaDsp">
\[  \frac{\partial y_1}{\partial x_1}, \quad \frac{\partial y_1}{\partial x_2};
\]
</p>
<p> similarly, <span class="tt">Model</span> \(g\) only defines   </p><p class="formulaDsp">
\[  \frac{\partial y_2}{\partial y_1}, \quad \frac{\partial y_2}{\partial x_3}
\]
</p>
<p> and <span class="tt">Model</span> \(h\) only defines   </p><p class="formulaDsp">
\[  \frac{\partial y}{\partial y_1}, \quad \frac{\partial y}{\partial y_2}, \quad \frac{\partial y}{\partial x_4}.
\]
</p>
<p> The assembly of the partial derivatives into the total derivative \(\partial y / \partial \boldsymbol{x}\) using the chain rule is handled by NEML2. This design serves as the fundation for a modular model implementation:</p><ul>
<li>Each model <em>does not</em> need to know its composition with others.</li>
<li>The same model partial derivatives can be reused in <em>any</em> composition.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="automatic-differentiation"></a>
Automatic differentiation</h1>
<p>Deriving and implementing derivatives of the forward operator can be cumbersome from times to times. NEML2 offers the option to use automatic differentiation (AD) to obtain derivatives. To enable automatic differentiation, one simply need to override the <a class="el" href="classneml2_1_1Model.html#a01c6f29b97001ac40bbac263fdaf3c7e" title="Request to use AD to compute the first derivative of a variable.">neml2::Model::request_AD</a> method and specify which derivatives should be computed using AD: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">MyModel::request_AD()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;const VariableBase *&gt; inputs = {&amp;foo, &amp;bar, &amp;baz, &amp;T};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// First derivatives</span></div>
<div class="line">  foo_dot.request_AD(inputs);</div>
<div class="line">  bar_dot.request_AD(inputs);</div>
<div class="line">  baz_dot.request_AD(inputs);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Second derivatives</span></div>
<div class="line">  foo_dot.request_AD(inputs, inputs);</div>
<div class="line">  bar_dot.request_AD(inputs, inputs);</div>
<div class="line">  baz_dot.request_AD(inputs, inputs);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Each model can use a mix of hand-coded derivatives and AD derivatives. However, an error will be raised if hand-coded derivatives are provided for those marked by <a class="el" href="classneml2_1_1VariableBase.html#a55c527e9ff1b59efd3876942c5017a3d">neml2::Variable::request_AD</a>.</dd></dl>
<p>Since a composed model uses chain rule to efficiently evaluate the total derivatives, automatic differentiation is disabled for <span class="tt">ComposedModel</span>. However, each of the child model can still use AD to calculate the <em>partial</em> derivatives of its own forward operator. Moreover, AD and non-AD models can be composed together.</p>
<h1 class="doxsection"><a class="anchor" id="model-assembly"></a>
Model assembly</h1>
<p>NEML2 stores each variable in contiguous memory, but does not guarantee contiguity across variables. This choice is made to allow for asynchronous evaluation (with the help of lazy tensors) and to reduce memory consumption (since variables can have different number of batch shapes). However, this choice is not ideal for a family of nonlinear material models whose constitutive updates require solving one (or more) implicit system of equations. To address such issue, NEML2 implements semi-contiguous variable and derivative containers in neml2::HVector and neml2::HMatrix. These containers store discontiguous tensor values in sparse, contiguous sequences. Please refer to the corresponding Doxygen documentation for implementation details. In the regular model development process, there is typically no need to directly interact with these internal containers.</p>
<h2 class="doxsection"><a class="anchor" id="axis-labeling"></a>
Axis labeling</h2>
<p>NEML2 provides a data structure named <a class="el" href="classneml2_1_1LabeledAxis.html" title="LabeledAxis">LabeledAxis</a> to create a contiguous layout for scattered input/output variables. Typically, each model contains an input axis for input variables and an output axis for output variables.</p>
<p>The <a class="el" href="classneml2_1_1LabeledAxis.html" title="LabeledAxis">LabeledAxis</a> contains all information regarding how the variables of interest should be contiguously laid out. In other words, the labeled axis maintains the mapping between variables and their contiguous slice along an axis. The following naming convention is used:</p><ul>
<li>Item: A labelable slice of data</li>
<li>Variable: An item that is also of a <a class="el" href="system-tensors.html#tensor-types" title="Tensor types">NEML2 primitive tensor type</a></li>
<li>Sub-axis: An item of type <span class="tt">LabeledAxis</span></li>
</ul>
<p>An axis can be labeled recursively, e.g.,</p>
<div class="fragment"><div class="line">     0 1 2 3 4 5     6     7 8 9 10 11 12   13   14</div>
<div class="line">/// |-----------| |-----| |              | |  | |  |</div>
<div class="line">///       a          b    |              | |  | |  |</div>
<div class="line">/// |-------------------| |--------------| |--| |--|</div>
<div class="line">///          sub                  a          b    c</div>
</div><!-- fragment --><p> The above example represents an axis of size 15. This axis has 4 items: <span class="tt">a</span>, <span class="tt">b</span>, <span class="tt">c</span>, and <span class="tt">sub</span>.</p><ul>
<li>"a" is a variable of storage size 6 (possibly of type <span class="tt">SR2</span>).</li>
<li>"b" is a variable of type <span class="tt">Scalar</span>.</li>
<li>"c" is a variable of type <span class="tt">Scalar</span>.</li>
<li>"sub" is a sub-axis of type <span class="tt">LabeledAxis</span>. "sub" by itself represents an axis of size 7, containing 2 items:<ul>
<li>"a" is a variable of storage size 6.</li>
<li>"b" is a variable of type <span class="tt">Scalar</span>.</li>
</ul>
</li>
</ul>
<p>Duplicate labels are <em>not</em> allowed on the same level of the axis, e.g. "a", "b", "c", and "sub" share the same level and so must be different. However, items on different levels of an axis can share the same label, e.g., "a" on the sub-axis "sub" has the same label as "a" on the main axis. In NEML2 convention, item names are always fully qualified, and a sub-axis is prefixed with a left slash, e.g. item "b" on the sub-axis "sub" can be denoted as "sub/b" on the main axis.</p>
<dl class="section note"><dt>Note</dt><dd>A label cannot contain: white spaces, quotes, left slash (<span class="tt">/</span>), or new line.</dd></dl>
<p>Due to performance considerations, a <span class="tt">LabeledAxis</span> can only be modified, e.g., adding/removing variables and sub-axis, at the time a model is constructed. After the model construction phase, the <span class="tt">LabeledAxis</span> associated with that model can no longer be modified over the entire course of the simulation.</p>
<p>Refer to the documentation for a complete list of APIs for creating and modifying a <a class="el" href="classneml2_1_1LabeledAxis.html" title="LabeledAxis">LabeledAxis</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
