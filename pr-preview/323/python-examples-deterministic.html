<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.16.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NEML2: Deterministic material model calibration</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
window.MathJax = {
  loader: {load: ['[tex]/ams', '[tex]/physics', '[tex]/boldsymbol']},
  tex: {packages: {'[+]': ['ams', 'physics', 'boldsymbol']},
        tags: 'ams'}
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-tabs.js" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <!-- Demo animations -->
  <script type="text/javascript" src="anime.min.js"></script>
  <script type="text/javascript" src="work-dispatcher.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler.js"></script>
  <script type="text/javascript" src="simple-scheduler-demo.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler-demo.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init();
    DoxygenAwesomeParagraphLink.init();
    DoxygenAwesomeInteractiveToc.init();
    DoxygenAwesomeTabs.init();
    SimpleSchedulerDemo.init();
    StaticHybridSchedulerDemo.init();
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">NEML2<span
                    id="projectnumber">&#160;2.0.0</span>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('python-examples-deterministic.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Deterministic material model calibration </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_build_2doc_2content_2tutorials_2python_2examples_2deterministic"></a></p>
<p>This is a complete example of using the pyzag bindings to NEML2 to calibrate a material model against experimental data. <span class="tt">demo_model.i</span> defines the constitutive model, which is a structural material model describing the evolution of strain and stress in the material under mechanical load. The particular demonstration is a fairly complex model where the material responds differently as a function of both temperature and strain rate. The material deformation is driven by an axial strain and all the other stress components are zero.</p>
<p>In this example we:</p><ol type="1">
<li>Load the model in from an input file and wrap it for use in pyzag</li>
<li>Setup a grid of "experimental" conditions spanning several strain rates and temperatures</li>
<li>Replace the original model parameters with samples from a narrow normal distrubtion, centered on the orignial model mean, and run the model over the experimental conditions. This then becomes our synthetic input data.</li>
<li>Replace the original model parameters with random initial guesses (taken from a very wide normal distribution around the true values).</li>
<li>Setup the model calibration with a gradient-descent method by scaling the model parameters and resulting gradient values.</li>
<li>Calibrate the model against the synthetic experimental data.</li>
<li>Plot the results and print the calibrated parameter values, to see how close we can come to the true values.</li>
</ol>
<p>The accuracy of the final model and the calibrated parameter values is heavily dependent on the choice of the normal distributions for the synthetic data and the initial parameter guesses. For narrow distributions for both the model can exactly recover the original parameter values. For wider distributions the calibrated model will not be exact, but will still accurately capture the mean of the synthetic tests.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> torch</div>
<div class="line"><span class="keyword">import</span> torch.distributions <span class="keyword">as</span> dist</div>
<div class="line"><span class="keyword">import</span> neml2</div>
<div class="line"><span class="keyword">from</span> pyzag <span class="keyword">import</span> nonlinear, reparametrization, chunktime</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</div>
<div class="line"><span class="keyword">import</span> tqdm</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md163"></a>
Setup parameters related to <em>how</em> we calibrate the model</h1>
<p>Choose which device to use. The <span class="tt">nchunk</span> parameter controls the time integration in <span class="tt">pyzag</span>. <span class="tt">pyzag</span> can vectorize the time integration itself, providing a larger bandwidth to the compute device. This helps speed up the calculation, particularly when running on a GPU. The optimal value will depend on your compute device.</p>
<div class="fragment"><div class="line">torch.manual_seed(0)</div>
<div class="line"> </div>
<div class="line">torch.set_default_dtype(torch.double)</div>
<div class="line"><span class="keywordflow">if</span> torch.cuda.is_available():</div>
<div class="line">    dev = <span class="stringliteral">&quot;cuda:0&quot;</span></div>
<div class="line"><span class="keywordflow">else</span>:</div>
<div class="line">    dev = <span class="stringliteral">&quot;cpu&quot;</span></div>
<div class="line">device = torch.device(dev)</div>
<div class="line"> </div>
<div class="line">nchunk = 50</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md164"></a>
Setup the synthetic experimental conditions</h1>
<p>Setup the loading conditions for the "experiments" we're going to run. These will span several strain rates (<span class="tt">nrate</span>) and temperatures (<span class="tt">ntemperature</span>). Overall, we'll run <span class="tt">nbatch</span> experiments. Also setup the maximum strain to pull the material through <span class="tt">max_strain</span> and the number of time steps we're going to use for integration <span class="tt">ntime</span>.</p>
<div class="fragment"><div class="line">nrate = 5</div>
<div class="line">ntemperature = 5</div>
<div class="line">nbatch = nrate * ntemperature</div>
<div class="line">max_strain = 0.25</div>
<div class="line">ntime = 100</div>
<div class="line">rates = torch.logspace(-6, 0, nrate, device=device)</div>
<div class="line">temperatures = torch.linspace(310.0, 1190.0, ntemperature, device=device)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md165"></a>
Define the variability in the synthetic data and for our initial guess at the parameters</h1>
<p>These control the variability in the synthetic data (<span class="tt">actual_cov</span>) and the variability of the initial guess at the parameter values (<span class="tt">guess_cov</span>)</p>
<div class="fragment"><div class="line">actual_cov = 0.025</div>
<div class="line">guess_cov = 0.2</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md166"></a>
Setup the actual model</h1>
<p>This class is a thin wrapper around the underlying <span class="tt">pyzag</span> wrapper for NEML2. All it does is take the input conditions (time, temperature, and strain), combine them into a single tensor, call the <span class="tt">pyzag</span> wrapper, and return the stress.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SolveStrain(torch.nn.Module):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Just integrate the model through some strain history</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Args:</span></div>
<div class="line"><span class="stringliteral">        discrete_equations: the pyzag wrapped model</span></div>
<div class="line"><span class="stringliteral">        nchunk (int): number of vectorized time steps</span></div>
<div class="line"><span class="stringliteral">        rtol (float): relative tolerance to use for Newton&#39;s method during time integration</span></div>
<div class="line"><span class="stringliteral">        atol (float): absolute tolerance to use for Newton&#39;s method during time integration</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, discrete_equations, nchunk=1, rtol=1.0e-6, atol=1.0e-4):</div>
<div class="line">        super().__init__()</div>
<div class="line">        self.discrete_equations = discrete_equations</div>
<div class="line">        self.nchunk = nchunk</div>
<div class="line">        self.cached_solution = <span class="keywordtype">None</span></div>
<div class="line">        self.rtol = rtol</div>
<div class="line">        self.atol = atol</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, time, temperature, loading, cache=False):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Integrate through some time/temperature/strain history and return stress</span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">            time (torch.tensor): batched times</span></div>
<div class="line"><span class="stringliteral">            temperature (torch.tensor): batched temperatures</span></div>
<div class="line"><span class="stringliteral">            loading (torch.tensor): loading conditions, which are the input strain in the first base index and then the stress (zero) in the remainder</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Keyword Args:</span></div>
<div class="line"><span class="stringliteral">            cache (bool): if true, cache the solution and use it as a predictor for the next call.</span></div>
<div class="line"><span class="stringliteral">                This heuristic can speed things up during inference where the model is called repeatedly with similar parameter values.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> cache <span class="keywordflow">and</span> self.cached_solution <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">            solver = nonlinear.RecursiveNonlinearEquationSolver(</div>
<div class="line">                self.discrete_equations,</div>
<div class="line">                step_generator=nonlinear.StepGenerator(self.nchunk),</div>
<div class="line">                predictor=nonlinear.FullTrajectoryPredictor(self.cached_solution),</div>
<div class="line">                nonlinear_solver=chunktime.ChunkNewtonRaphson(rtol=self.rtol, atol=self.atol),</div>
<div class="line">            )</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            solver = nonlinear.RecursiveNonlinearEquationSolver(</div>
<div class="line">                self.discrete_equations,</div>
<div class="line">                step_generator=nonlinear.StepGenerator(self.nchunk),</div>
<div class="line">                predictor=nonlinear.PreviousStepsPredictor(),</div>
<div class="line">                nonlinear_solver=chunktime.ChunkNewtonRaphson(rtol=self.rtol, atol=self.atol),</div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># We could pass this in as input, but it&#39;s easy enough to do here</span></div>
<div class="line">        control = torch.zeros_like(loading)</div>
<div class="line">        control[..., 1:] = 1.0</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Setup</span></div>
<div class="line">        forces = {</div>
<div class="line">            <span class="stringliteral">&quot;forces/t&quot;</span>: <a class="code hl_class" href="classneml2_1_1Scalar.html">neml2.Scalar</a>(time, 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/T&quot;</span>: <a class="code hl_class" href="classneml2_1_1Scalar.html">neml2.Scalar</a>(temperature, 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/fixed_values&quot;</span>: <a class="code hl_class" href="classneml2_1_1SR2.html">neml2.SR2</a>(loading, 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/control&quot;</span>: <a class="code hl_class" href="classneml2_1_1SR2.html">neml2.SR2</a>(control, 0),</div>
<div class="line">        }</div>
<div class="line">        forces = [forces[key] <span class="keywordflow">for</span> key <span class="keywordflow">in</span> self.discrete_equations.fmap]</div>
<div class="line">        forces = neml2.assemble_vector(forces, self.discrete_equations.flayout).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line">        state0 = torch.zeros(</div>
<div class="line">            forces.shape[1:-1] + (self.discrete_equations.nstate,), device=forces.device</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        result = nonlinear.solve_adjoint(solver, state0, len(forces), forces)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> cache:</div>
<div class="line">            self.cached_solution = result.detach().clone()</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> result[..., 0:1]</div>
<div class="ttc" id="aclassneml2_1_1SR2_html"><div class="ttname"><a href="classneml2_1_1SR2.html">neml2::SR2</a></div><div class="ttdoc">The symmetric second order tensor.</div><div class="ttdef"><b>Definition</b> SR2.h:46</div></div>
<div class="ttc" id="aclassneml2_1_1Scalar_html"><div class="ttname"><a href="classneml2_1_1Scalar.html">neml2::Scalar</a></div><div class="ttdoc">Scalar.</div><div class="ttdef"><b>Definition</b> Scalar.h:38</div></div>
<div class="ttc" id="anamespacetorch_html"><div class="ttname"><a href="namespacetorch.html">torch</a></div><div class="ttdef"><b>Definition</b> TransientDriver.h:32</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md167"></a>
Actually setup the model</h2>
<p>Load the NEML model from disk, wrap it in both the <span class="tt">pyzag</span> wrapper and our thin wrapper class above. Exclude some of the model parameters we don't want to calibrate.</p>
<div class="fragment"><div class="line">nmodel = neml2.load_nonlinear_system(<span class="stringliteral">&quot;demo_model.i&quot;</span>, <span class="stringliteral">&quot;eq_sys&quot;</span>)</div>
<div class="line">nmodel.to(device=device)</div>
<div class="line">pmodel = neml2.pyzag.NEML2PyzagModel(</div>
<div class="line">    nmodel,</div>
<div class="line">    exclude_parameters=[</div>
<div class="line">        <span class="stringliteral">&quot;elasticity_E&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;elasticity_nu&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;R_X&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;d_X&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;mu_X&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;mu_Y&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;yield_zero_sy&quot;</span>,</div>
<div class="line">    ],</div>
<div class="line">)</div>
<div class="line">model = SolveStrain(pmodel)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md168"></a>
Create the input tensors</h1>
<p>Actually setup the full input tensors based on the parameters above</p>
<div class="fragment"><div class="line">time = torch.zeros((ntime, nrate, ntemperature), device=device)</div>
<div class="line">loading = torch.zeros((ntime, nrate, ntemperature, 6), device=device)</div>
<div class="line">temperature = torch.zeros((ntime, nrate, ntemperature), device=device)</div>
<div class="line"><span class="keywordflow">for</span> i, rate <span class="keywordflow">in</span> enumerate(rates):</div>
<div class="line">    time[:, i] = torch.linspace(0, max_strain / rate, ntime, device=device)[:, <span class="keywordtype">None</span>]</div>
<div class="line">loading[..., 0] = torch.linspace(0, max_strain, ntime, device=device)[:, <span class="keywordtype">None</span>, <span class="keywordtype">None</span>]</div>
<div class="line"><span class="keywordflow">for</span> i, T <span class="keywordflow">in</span> enumerate(temperatures):</div>
<div class="line">    temperature[:, :, i] = T</div>
<div class="line">time = time.reshape((ntime, -1))</div>
<div class="line">temperature = temperature.reshape((ntime, -1))</div>
<div class="line">loading = loading.reshape((ntime, -1, 6))</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md169"></a>
Replace the model parameters with random values</h1>
<p>Sampled from a normal distribution controlled by the <span class="tt">actual_cov</span> parameter.</p>
<p>This controls the randomness in the input synthetic test data</p>
<div class="fragment"><div class="line"><span class="comment"># Replace with samples from normal</span></div>
<div class="line">actual_parameter_values = {}</div>
<div class="line"><span class="keywordflow">for</span> n, p <span class="keywordflow">in</span> model.named_parameters():</div>
<div class="line">    actual_parameter_values[n] = p.data.detach().clone().cpu()</div>
<div class="line">    ndist = dist.Normal(p.data, torch.abs(p.data) * actual_cov).expand((nbatch,) + p.shape)</div>
<div class="line">    p.data = ndist.sample().to(device)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md170"></a>
Run the model to generate the synthetic data</h1>
<div class="fragment"><div class="line"><span class="keyword">with</span> torch.no_grad():</div>
<div class="line">    data = model(time, temperature, loading)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md171"></a>
Plot the synthetic data</h1>
<div class="fragment"><div class="line">plt.plot(loading.cpu()[..., 0], data[..., 0].cpu())</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Strain (mm/mm)&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Stress (MPa)&quot;</span>)</div>
<div class="line">plt.title(<span class="stringliteral">&quot;Input data -- all conditions&quot;</span>)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/deterministic_19_0.png" alt="png" class="inline"/></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md172"></a>
Setup the model for training</h1>
<p>Replace the parameter values with random initial guesses, with variability controlled by the <span class="tt">guess_cov</span> parameter.</p>
<div class="fragment"><div class="line"><span class="comment"># Now replace our original parameter with random values over a range</span></div>
<div class="line">guess_parameter_values = {}</div>
<div class="line"><span class="keywordflow">for</span> n, p <span class="keywordflow">in</span> model.named_parameters():</div>
<div class="line">    p.data = torch.normal(actual_parameter_values[n], torch.abs(actual_parameter_values[n])*guess_cov).to(device)</div>
<div class="line">    guess_parameter_values[n] = p.data.detach().clone()</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md173"></a>
Scale the model parameters</h1>
<p>Our material model parameters have units. In general, the parameter values will have different magnitudes from each other, which affects the scale of the gradients. Unbalanced gradients in turn affect the convergence of gradient descent optimization methods.</p>
<p>Typically we'd scale the training data to fix this problem. However, again our data has units and a physical meaning we want to preserve.</p>
<p>As an alternative we can scale the parameter values themselves both to clip the values to a physical range and to scale the gradients and hopefully improve the convergence of the optimization step. We do that here, in a way that should be mostly invisible to the training algorithms.</p>
<div class="fragment"><div class="line"><span class="comment"># Scale to get better performance</span></div>
<div class="line">A_scaler = reparametrization.RangeRescale(</div>
<div class="line">    torch.tensor(-12.0, device=device), torch.tensor(-4.0, device=device)</div>
<div class="line">)</div>
<div class="line">B_scaler = reparametrization.RangeRescale(</div>
<div class="line">    torch.tensor(-1.0, device=device), torch.tensor(-0.5, device=device)</div>
<div class="line">)</div>
<div class="line">C_scaler = reparametrization.RangeRescale(</div>
<div class="line">    torch.tensor(-8.0, device=device), torch.tensor(-3.0, device=device)</div>
<div class="line">)</div>
<div class="line">R_scaler = reparametrization.RangeRescale(</div>
<div class="line">    torch.tensor([0.0, 0.0, 0.0, 0.0], device=device),</div>
<div class="line">    torch.tensor([500.0, 500.0, 500.0, 500.0], device=device),</div>
<div class="line">)</div>
<div class="line">d_scaler = reparametrization.RangeRescale(</div>
<div class="line">    torch.tensor([0.01, 0.01, 0.01, 0.01], device=device),</div>
<div class="line">    torch.tensor([50.0, 50.0, 50.0, 50.0], device=device),</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">model_reparameterizer = reparametrization.Reparameterizer(</div>
<div class="line">    {</div>
<div class="line">        <span class="stringliteral">&quot;discrete_equations.A_value&quot;</span>: A_scaler,</div>
<div class="line">        <span class="stringliteral">&quot;discrete_equations.B_value&quot;</span>: B_scaler,</div>
<div class="line">        <span class="stringliteral">&quot;discrete_equations.C_value&quot;</span>: C_scaler,</div>
<div class="line">        <span class="stringliteral">&quot;discrete_equations.R_Y&quot;</span>: R_scaler,</div>
<div class="line">        <span class="stringliteral">&quot;discrete_equations.d_Y&quot;</span>: d_scaler,</div>
<div class="line">    },</div>
<div class="line">    error_not_provided=<span class="keyword">True</span>,</div>
<div class="line">)</div>
<div class="line">model_reparameterizer(model)</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md174"></a>
Run the model with the initial parameter values</h1>
<p>Just to see how far away from the training data we starting from.</p>
<div class="fragment"><div class="line"><span class="comment"># Generate the initial results so we know where we are starting from</span></div>
<div class="line"><span class="keyword">with</span> torch.no_grad():</div>
<div class="line">    initial_results = model(time, temperature, loading)</div>
</div><!-- fragment --><div class="fragment"><div class="line">plt.plot(loading.cpu()[..., 0], data.cpu()[..., 0], <span class="stringliteral">&quot;k-&quot;</span>)</div>
<div class="line">plt.plot(loading.cpu()[..., 0], initial_results.cpu()[..., 0], <span class="stringliteral">&quot;k--&quot;</span>)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Strain (mm/mm)&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Stress (MPa)&quot;</span>)</div>
<div class="line">plt.title(<span class="stringliteral">&quot;Initial comparison&quot;</span>)</div>
<div class="line">handles = [</div>
<div class="line">    Line2D([], [], linestyle=<span class="stringliteral">&quot;-&quot;</span>, color=<span class="stringliteral">&quot;k&quot;</span>, label=<span class="stringliteral">&quot;Data&quot;</span>),</div>
<div class="line">    Line2D([], [], linestyle=<span class="stringliteral">&quot;--&quot;</span>, color=<span class="stringliteral">&quot;k&quot;</span>, label=<span class="stringliteral">&quot;Initial results&quot;</span>),</div>
<div class="line">]</div>
<div class="line">plt.legend(handles=handles)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/deterministic_26_0.png" alt="png" class="inline"/></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md175"></a>
Calibrate the model against the synthetic data</h1>
<p>Apply a fairly standard gradient-descent algorithm to adjust the model parameters to better match the synthetic data. Plot the loss versus iteration data from training.</p>
<div class="fragment"><div class="line">niter = 200</div>
<div class="line">lr = 5.0e-3</div>
<div class="line">optimizer = torch.optim.Adam(model.parameters(), lr=lr)</div>
<div class="line">loss_fn = torch.nn.MSELoss()</div>
<div class="line"> </div>
<div class="line">titer = tqdm.tqdm(</div>
<div class="line">    range(niter),</div>
<div class="line">    bar_format=<span class="stringliteral">&quot;{desc}{percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt}{postfix}&quot;</span>,</div>
<div class="line">)</div>
<div class="line">titer.set_description(<span class="stringliteral">&quot;Loss:&quot;</span>)</div>
<div class="line">loss_history = []</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> titer:</div>
<div class="line">    optimizer.zero_grad()</div>
<div class="line">    res = model(time, temperature, loading, cache=<span class="keyword">True</span>)</div>
<div class="line">    loss = loss_fn(res, data)</div>
<div class="line">    loss.backward()</div>
<div class="line">    loss_history.append(loss.detach().clone().cpu())</div>
<div class="line">    titer.set_description(<span class="stringliteral">&quot;Loss: %3.2e&quot;</span> % loss_history[-1])</div>
<div class="line">    optimizer.step()</div>
<div class="line"> </div>
<div class="line">plt.loglog(loss_history, label=<span class="stringliteral">&quot;Training&quot;</span>)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Iteration&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;MSE&quot;</span>)</div>
<div class="line">plt.legend(loc=<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">plt.title(<span class="stringliteral">&quot;Loss history&quot;</span>)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --> <pre class="fragment">Loss: 2.53e+04: 100%|██████████|200/200
</pre><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/deterministic_28_1.png" alt="png" class="inline"/></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md176"></a>
Plot the calibrated model predictions</h1>
<p>See how accurately the calibrated model recovers the synthetic data.</p>
<div class="fragment"><div class="line">plt.plot(loading.cpu()[..., 0], data.cpu()[...,0], <span class="stringliteral">&quot;k-&quot;</span>)</div>
<div class="line">plt.plot(loading.cpu()[..., 0], res.detach().cpu()[...,0], <span class="stringliteral">&quot;k--&quot;</span>)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Strain (mm/mm)&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Stress (MPa)&quot;</span>)</div>
<div class="line">plt.title(<span class="stringliteral">&quot;Final comparison&quot;</span>)</div>
<div class="line">plt.show()</div>
</div><!-- fragment --><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/deterministic_30_0.png" alt="png" class="inline"/></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md177"></a>
Print the calibrated model coefficients</h1>
<p>These may vary sigifnicantly from the actual mean values, particularly if you used a large variance when sampling the parameters to generate the synthetic data.</p>
<div class="fragment"><div class="line">print(<span class="stringliteral">&quot;The results:&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> n, p <span class="keywordflow">in</span> model.discrete_equations.named_parameters():</div>
<div class="line">    nice_name = n.split(<span class="stringliteral">&#39;.&#39;</span>)[-2]</div>
<div class="line">    ref_name = <span class="stringliteral">&quot;discrete_equations.&quot;</span> + nice_name</div>
<div class="line">    scaler = model_reparameterizer.map_dict[ref_name]</div>
<div class="line">    print(nice_name)</div>
<div class="line">    print(<span class="stringliteral">&quot;\tInitial: \t&quot;</span> + str(guess_parameter_values[ref_name].cpu()))</div>
<div class="line">    print(<span class="stringliteral">&quot;\tOptimized: \t&quot;</span> + str(scaler(p.data).cpu()))</div>
<div class="line">    print(<span class="stringliteral">&quot;\tTrue value: \t&quot;</span> + str(actual_parameter_values[ref_name].cpu()))</div>
</div><!-- fragment --> <pre class="fragment">The results:
A_value
    Initial:    tensor(-6.0041)
    Optimized:  tensor(-8.8544)
    True value:     tensor(-8.6790)
B_value
    Initial:    tensor(-0.7877)
    Optimized:  tensor(-0.9448)
    True value:     tensor(-0.7440)
C_value
    Initial:    tensor(-7.7675)
    Optimized:  tensor(-5.8379)
    True value:     tensor(-5.4100)
R_Y
    Initial:    tensor([334.1059, 156.6191,  72.0281,  54.0335])
    Optimized:  tensor([391.3497, 342.9169, 215.5262,  95.8719])
    True value:     tensor([300., 200., 100.,  50.])
d_Y
    Initial:    tensor([35.0282, 17.1230, 13.7900, 10.5681])
    Optimized:  tensor([43.9882, 34.7154, 30.0079, 19.7838])
    True value:     tensor([30., 20., 15., 12.])
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
