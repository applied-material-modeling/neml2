<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.16.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NEML2: Crystal plasticity formulations</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
window.MathJax = {
  loader: {load: ['[tex]/ams', '[tex]/physics', '[tex]/boldsymbol']},
  tex: {packages: {'[+]': ['ams', 'physics', 'boldsymbol']},
        tags: 'ams'}
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-tabs.js" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <!-- Demo animations -->
  <script type="text/javascript" src="anime.min.js"></script>
  <script type="text/javascript" src="work-dispatcher.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler.js"></script>
  <script type="text/javascript" src="simple-scheduler-demo.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler-demo.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init();
    DoxygenAwesomeParagraphLink.init();
    DoxygenAwesomeInteractiveToc.init();
    DoxygenAwesomeTabs.init();
    SimpleSchedulerDemo.init();
    StaticHybridSchedulerDemo.init();
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">NEML2<span
                    id="projectnumber">&#160;2.0.0</span>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('python-examples-crystal_plasticity-compare_formulations.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Crystal plasticity formulations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_build_2doc_2content_2tutorials_2python_2examples_2crystal__plasticity_2compare__formulations"></a></p>
<p>There are two common ways to formulate crystal plasticity kinematics:</p><ol type="1">
<li>Integrate the elastic stretch and elastic rotation separately with two (coupled) rate equations.</li>
<li>Integrate the plastic deformation gradient $F_p$ directly from the plastic spatial velocity gradient $l_p$.</li>
</ol>
<p>Both formulations are based on the usual multiplicative decomposition of the deformation gradient into elastic and plastic parts $F = F_e F_p$. This notebook calls the first approach the "separated" method and the second the "integrated" method (because the first splits the kinematics into two coupled equations and the second integrates a single equation for $F_p$).</p>
<p>It's easy to formulate a crystal model either way in NEML2 reusing most of detailed constitutive model objects like the hardening law, the slip law, and the crystal geometry. In fact the vast majority of the objects are shared between the two models with only a few specialized submodels required for each.</p>
<p>This example runs equivalent separated and integrated models through the same deformation history (rolling to 50% rolling strain) and plots a comparison. You can also use this notebook to look at differences in performance, though we have not done detailed performance optimization on either.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md147"></a>
Importing required libraries and setting up</h1>
<p>This example will run on the GPU with CUDA if available. <span class="tt">nchunk</span> is the chunk size for the <span class="tt">pyzag</span> integration, <span class="tt">ncrystal</span> is the number of random initial crystal orientations to use.</p>
<p>This example simulates rolling in an FCC material. <span class="tt">rate</span> sets the strain rate, <span class="tt">total_rolling_strain</span> the reduction strain, and <span class="tt">ntime</span> the number of time steps to take.</p>
<p>We need to calculate both the deformation rate/vorticity and the deformation gradient</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">from</span> matplotlib.lines <span class="keyword">import</span> Line2D</div>
<div class="line"><span class="keyword">import</span> torch</div>
<div class="line"><span class="keyword">import</span> neml2</div>
<div class="line"><span class="keyword">import</span> neml2.tensors</div>
<div class="line"><span class="keyword">from</span> pyzag <span class="keyword">import</span> nonlinear, chunktime</div>
<div class="line"><span class="keyword">import</span> neml2.postprocessing</div>
</div><!-- fragment --><div class="fragment"><div class="line">torch.set_default_dtype(torch.double)</div>
<div class="line"><span class="keywordflow">if</span> torch.cuda.is_available():</div>
<div class="line">    dev = <span class="stringliteral">&quot;cuda:0&quot;</span></div>
<div class="line"><span class="keywordflow">else</span>:</div>
<div class="line">    dev = <span class="stringliteral">&quot;cpu&quot;</span></div>
<div class="line">device = torch.device(dev)</div>
<div class="line"> </div>
<div class="line">nchunk = 10</div>
<div class="line">ncrystal = 500</div>
</div><!-- fragment --><div class="fragment"><div class="line">rate = 0.0001</div>
<div class="line">total_rolling_strain = 0.5</div>
<div class="line">ntime = 2500</div>
<div class="line">end_time = total_rolling_strain / rate</div>
<div class="line">initial_orientations = neml2.tensors.Rot.rand((ncrystal,), ()).<a class="code hl_namespace" href="namespacetorch.html">torch</a>().to(device)</div>
<div class="ttc" id="anamespacetorch_html"><div class="ttname"><a href="namespacetorch.html">torch</a></div><div class="ttdef"><b>Definition</b> TransientDriver.h:32</div></div>
</div><!-- fragment --><div class="fragment"><div class="line">deformation_rate = torch.zeros((ntime, ncrystal, 6), device=device)</div>
<div class="line">deformation_rate[:, :, 1] = rate</div>
<div class="line">deformation_rate[:, :, 2] = -rate</div>
<div class="line">times = (</div>
<div class="line">    torch.linspace(0, end_time, ntime, device=device)</div>
<div class="line">    .unsqueeze(-1)</div>
<div class="line">    .unsqueeze(-1)</div>
<div class="line">    .expand((ntime, ncrystal, 1))</div>
<div class="line">)</div>
<div class="line">vorticity = torch.zeros((ntime, ncrystal, 3), device=device)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment"># Now get the integrated deformation gradient</span></div>
<div class="line">full_spatial_velocity_gradient = (</div>
<div class="line">    neml2.tensors.R2(neml2.tensors.SR2(deformation_rate)).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line">    + neml2.tensors.R2(neml2.tensors.WR2(vorticity)).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line">)</div>
<div class="line">F = torch.zeros_like(full_spatial_velocity_gradient)</div>
<div class="line">F[0] = torch.eye(3, device=device)</div>
<div class="line">dt = torch.diff(times, dim=0)</div>
<div class="line">Finc = torch.linalg.matrix_exp(full_spatial_velocity_gradient[:-1] * dt.unsqueeze(-1))</div>
<div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(1, ntime):</div>
<div class="line">    F[i] = Finc[i - 1] @ F[i - 1]</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md148"></a>
pyzag driver for the separated model</h1>
<p>For more details on the pyzag driver used here see the deterministic and stochastic inference examples. This helper object just lets us integrate the crystal model using pyzag</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SolveSeparate(torch.nn.Module):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Just integrate the model through some strain history</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Args:</span></div>
<div class="line"><span class="stringliteral">        discrete_equations: the pyzag wrapped model</span></div>
<div class="line"><span class="stringliteral">        nchunk (int): number of vectorized time steps</span></div>
<div class="line"><span class="stringliteral">        rtol (float): relative tolerance to use for Newton&#39;s method during time integration</span></div>
<div class="line"><span class="stringliteral">        atol (float): absolute tolerance to use for Newton&#39;s method during time integration</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, discrete_equations, nchunk=1, rtol=1.0e-6, atol=1.0e-8):</div>
<div class="line">        super().__init__()</div>
<div class="line">        self.discrete_equations = discrete_equations</div>
<div class="line">        self.nchunk = nchunk</div>
<div class="line">        self.rtol = rtol</div>
<div class="line">        self.atol = atol</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, time, deformation_rate, vorticity, initial_orientations=None):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Integrate through some time/temperature/strain history and return stress</span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">            time (torch.tensor): batched times</span></div>
<div class="line"><span class="stringliteral">            deformation_rate (torch.tensor): batched deformation rates</span></div>
<div class="line"><span class="stringliteral">            vorticity (torch.tensor): batched vocticities</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Keyword Args:</span></div>
<div class="line"><span class="stringliteral">            initial_orientation (torch.tensor): if provided, the initial orientations for each crystal</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        solver = nonlinear.RecursiveNonlinearEquationSolver(</div>
<div class="line">            self.discrete_equations,</div>
<div class="line">            step_generator=nonlinear.StepGenerator(self.nchunk),</div>
<div class="line">            predictor=nonlinear.PreviousStepsPredictor(),</div>
<div class="line">            nonlinear_solver=chunktime.ChunkNewtonRaphson(rtol=self.rtol, atol=self.atol),</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Setup</span></div>
<div class="line">        forces = {</div>
<div class="line">            <span class="stringliteral">&quot;forces/t&quot;</span>: <a class="code hl_class" href="classneml2_1_1Scalar.html">neml2.Scalar</a>(time.squeeze(-1), 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/deformation_rate&quot;</span>: <a class="code hl_class" href="classneml2_1_1SR2.html">neml2.SR2</a>(deformation_rate, 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/vorticity&quot;</span>: <a class="code hl_class" href="classneml2_1_1WR2.html">neml2.WR2</a>(vorticity, 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/initial_orientation&quot;</span>: <a class="code hl_class" href="classneml2_1_1Rot.html">neml2.Rot</a>(initial_orientations, 0),</div>
<div class="line">        }</div>
<div class="line">        forces = [forces[key] <span class="keywordflow">for</span> key <span class="keywordflow">in</span> self.discrete_equations.fmap]</div>
<div class="line">        forces = neml2.assemble_vector(forces, self.discrete_equations.flayout).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line">        state0 = [<a class="code hl_class" href="classneml2_1_1Tensor.html">neml2.Tensor</a>()] * len(self.discrete_equations.smap)</div>
<div class="line">        <span class="keywordflow">if</span> initial_orientations <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">            i = self.discrete_equations.smap.index(<span class="stringliteral">&quot;state/orientation&quot;</span>)</div>
<div class="line">            state0[i] = <a class="code hl_class" href="classneml2_1_1Tensor.html">neml2.Tensor</a>(initial_orientations, 1)</div>
<div class="line">        state0 = neml2.assemble_vector(state0, self.discrete_equations.slayout).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line"> </div>
<div class="line">        result = nonlinear.solve_adjoint(solver, state0, len(forces), forces)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> result</div>
<div class="ttc" id="aclassneml2_1_1Rot_html"><div class="ttname"><a href="classneml2_1_1Rot.html">neml2::Rot</a></div><div class="ttdoc">Rotation stored as modified Rodrigues parameters.</div><div class="ttdef"><b>Definition</b> Rot.h:49</div></div>
<div class="ttc" id="aclassneml2_1_1SR2_html"><div class="ttname"><a href="classneml2_1_1SR2.html">neml2::SR2</a></div><div class="ttdoc">The symmetric second order tensor.</div><div class="ttdef"><b>Definition</b> SR2.h:46</div></div>
<div class="ttc" id="aclassneml2_1_1Scalar_html"><div class="ttname"><a href="classneml2_1_1Scalar.html">neml2::Scalar</a></div><div class="ttdoc">Scalar.</div><div class="ttdef"><b>Definition</b> Scalar.h:38</div></div>
<div class="ttc" id="aclassneml2_1_1Tensor_html"><div class="ttname"><a href="classneml2_1_1Tensor.html">neml2::Tensor</a></div><div class="ttdef"><b>Definition</b> Tensor.h:49</div></div>
<div class="ttc" id="aclassneml2_1_1WR2_html"><div class="ttname"><a href="classneml2_1_1WR2.html">neml2::WR2</a></div><div class="ttdoc">A skew-symmetric second order tensor, represented as an axial vector.</div><div class="ttdef"><b>Definition</b> WR2.h:43</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md149"></a>
Simulate rolling deformation for the seperated model</h1>
<p>Simulate the rolling deformation and extract the final crystal orientations</p>
<div class="fragment"><div class="line">nmodel_separate = neml2.load_nonlinear_system(<span class="stringliteral">&quot;crystal.i&quot;</span>, <span class="stringliteral">&quot;eq_sys&quot;</span>)</div>
<div class="line">nmodel_separate.to(device = device)</div>
<div class="line">model_separate = SolveSeparate(neml2.pyzag.NEML2PyzagModel(nmodel_separate), nchunk = nchunk)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">with</span> torch.no_grad():</div>
<div class="line">    results_seperate = model_separate(times, deformation_rate, vorticity, initial_orientations = initial_orientations)</div>
<div class="line">orientations_separate = neml2.tensors.Rot(results_seperate[-1,:,6:9])</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md150"></a>
ODF reconstruction for the seperated model</h1>
<p>Reconstruct the ODF from the discrete data. Uncommenting the two lines will optimize the kernel half-width with the built in routine (which uses a cross-validation approach). However, for consistency between the two methods, we'll use a fixed half width for both.</p>
<div class="fragment"><div class="line">odf_separate = neml2.postprocessing.odf.KDEODF(</div>
<div class="line">    orientations_separate, neml2.postprocessing.odf.DeLaValleePoussinKernel(torch.tensor(0.2))</div>
<div class="line">)</div>
<div class="line">odf_separate.optimize_kernel(verbose = <span class="keyword">True</span>)</div>
<div class="line">print(odf_separate.kernel.h)</div>
</div><!-- fragment --> <pre class="fragment">loss: -4.78125e-01: 100%|██████████| 50/50 [00:36&lt;00:00,  1.36it/s]

Parameter containing:
tensor(0.2319, requires_grad=True)
</pre><h1 class="doxsection"><a class="anchor" id="autotoc_md151"></a>
pyzag driver for the integrated model</h1>
<p>Same thing as for the separated model, just now for the integrated form where we take the deformation gradient as input. Don't forget to set the initial plastic deformation gradient to the identity!</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SolveIntegrated(torch.nn.Module):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Just integrate the model through some strain history</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Args:</span></div>
<div class="line"><span class="stringliteral">        discrete_equations: the pyzag wrapped model</span></div>
<div class="line"><span class="stringliteral">        nchunk (int): number of vectorized time steps</span></div>
<div class="line"><span class="stringliteral">        rtol (float): relative tolerance to use for Newton&#39;s method during time integration</span></div>
<div class="line"><span class="stringliteral">        atol (float): absolute tolerance to use for Newton&#39;s method during time integration</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, discrete_equations, nchunk=1, rtol=1.0e-6, atol=1.0e-8):</div>
<div class="line">        super().__init__()</div>
<div class="line">        self.discrete_equations = discrete_equations</div>
<div class="line">        self.nchunk = nchunk</div>
<div class="line">        self.rtol = rtol</div>
<div class="line">        self.atol = atol</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, time, deformation_gradient, initial_orientations=None):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Integrate through some time/temperature/strain history and return stress</span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">            time (torch.tensor): batched times</span></div>
<div class="line"><span class="stringliteral">            deformation_gradient (torch.tensor): batched deformation gradients</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Keyword Args:</span></div>
<div class="line"><span class="stringliteral">            initial_orientation (torch.tensor): if provided, the initial orientations for each crystal</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        solver = nonlinear.RecursiveNonlinearEquationSolver(</div>
<div class="line">            self.discrete_equations,</div>
<div class="line">            step_generator=nonlinear.StepGenerator(self.nchunk),</div>
<div class="line">            predictor=nonlinear.PreviousStepsPredictor(),</div>
<div class="line">            nonlinear_solver=chunktime.ChunkNewtonRaphson(rtol=self.rtol, atol=self.atol),</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Setup</span></div>
<div class="line">        forces = {</div>
<div class="line">            <span class="stringliteral">&quot;forces/t&quot;</span>: <a class="code hl_class" href="classneml2_1_1Scalar.html">neml2.Scalar</a>(time.squeeze(-1), 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/F&quot;</span>: <a class="code hl_class" href="classneml2_1_1R2.html">neml2.R2</a>(deformation_gradient, 0),</div>
<div class="line">            <span class="stringliteral">&quot;forces/r&quot;</span>: <a class="code hl_class" href="classneml2_1_1Rot.html">neml2.Rot</a>(initial_orientations, 0),</div>
<div class="line">        }</div>
<div class="line">        forces = [forces[key] <span class="keywordflow">for</span> key <span class="keywordflow">in</span> self.discrete_equations.fmap]</div>
<div class="line">        forces = neml2.assemble_vector(forces, self.discrete_equations.flayout).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line">        state0 = [<a class="code hl_class" href="classneml2_1_1Tensor.html">neml2.Tensor</a>()] * len(self.discrete_equations.smap)</div>
<div class="line">        i = self.discrete_equations.smap.index(<span class="stringliteral">&quot;state/Fp&quot;</span>)</div>
<div class="line">        state0[i] = neml2.tensors.Tensor(</div>
<div class="line">            torch.eye(3, device=time.device).unsqueeze(0).expand(time.shape[1:2] + (3, 3)), 1</div>
<div class="line">        )</div>
<div class="line">        state0 = neml2.assemble_vector(state0, self.discrete_equations.slayout).<a class="code hl_namespace" href="namespacetorch.html">torch</a>()</div>
<div class="line"> </div>
<div class="line">        result = nonlinear.solve_adjoint(solver, state0, len(forces), forces)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> result</div>
<div class="ttc" id="aclassneml2_1_1R2_html"><div class="ttname"><a href="classneml2_1_1R2.html">neml2::R2</a></div><div class="ttdoc">Base class for second order tensor.</div><div class="ttdef"><b>Definition</b> R2.h:49</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md152"></a>
Simulate for the multiplicative model</h1>
<p>Again, simulate rolling deformation</p>
<div class="fragment"><div class="line">nmodel_integrated = neml2.load_nonlinear_system(<span class="stringliteral">&quot;crystal_integrated.i&quot;</span>, <span class="stringliteral">&quot;eq_sys&quot;</span>)</div>
<div class="line">nmodel_integrated.to(device=device)</div>
<div class="line">model_integrated = SolveIntegrated(neml2.pyzag.NEML2PyzagModel(nmodel_integrated), nchunk=nchunk)</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">with</span> torch.no_grad():</div>
<div class="line">    results_integrated = model_integrated(times, F, initial_orientations=initial_orientations)</div>
<div class="line">end_results_integrated = results_integrated[-1]</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md153"></a>
Extract the orientations for the multiplicative model</h1>
<p>This takes some doing. We first need to get $F_p$ from the state, then calculate $F_e = F F_p^{-1}$, then do a polar decomposition to get the rotation as a matrix, then convert to modified Rodrigues parameters. Finally compose with the original texture to get the final, deformed texture.</p>
<div class="fragment"><div class="line">split_state = neml2.disassemble_vector(</div>
<div class="line">    <a class="code hl_class" href="classneml2_1_1Tensor.html">neml2.Tensor</a>(end_results_integrated, 1), model_integrated.discrete_equations.slayout</div>
<div class="line">)</div>
<div class="line">iFp = model_integrated.discrete_equations.smap.index(<span class="stringliteral">&quot;state/Fp&quot;</span>)</div>
<div class="line">Fp = split_state[iFp].<a class="code hl_namespace" href="namespacetorch.html">torch</a>().reshape(-1, 3, 3)</div>
<div class="line">Flast = F[-1]</div>
<div class="line">Fe = Flast @ torch.linalg.inv(Fp)</div>
<div class="line">U, S, Vh = torch.linalg.svd(Fe)</div>
<div class="line">Re = U @ Vh</div>
<div class="line">Ue = Vh.transpose(-2, -1).conj() @ torch.diag_embed(S, dim1=-2, dim2=-1) @ Vh</div>
<div class="line">Re_mrp = neml2.tensors.Rot.fill_matrix(neml2.tensors.R2(Re))</div>
<div class="line"> </div>
<div class="line">Q0 = neml2.tensors.Rot(initial_orientations)</div>
<div class="line">Q = Re_mrp * Q0</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md154"></a>
Construct the ODF for the multiplicative model results</h1>
<p>Basically the same as for the separated approach.</p>
<div class="fragment"><div class="line">odf_integrated = neml2.postprocessing.odf.KDEODF(</div>
<div class="line">    Q, neml2.postprocessing.odf.DeLaValleePoussinKernel(torch.tensor(0.2))</div>
<div class="line">)</div>
<div class="line">odf_integrated.optimize_kernel(verbose = <span class="keyword">True</span>)</div>
<div class="line">print(odf_integrated.kernel.h)</div>
</div><!-- fragment --> <pre class="fragment">loss: -4.78211e-01: 100%|██████████| 50/50 [00:36&lt;00:00,  1.35it/s]

Parameter containing:
tensor(0.2318, requires_grad=True)
</pre><h1 class="doxsection"><a class="anchor" id="autotoc_md155"></a>
Plot the pole figures</h1>
<p>Use the reconstructed ODFs to plot continuous 111 polefigure</p>
<div class="fragment"><div class="line">neml2.postprocessing.pretty_plot_pole_figure_odf(</div>
<div class="line">    odf_separate,</div>
<div class="line">    torch.tensor([1, 1, 1.0], device=device),</div>
<div class="line">    crystal_symmetry=<span class="stringliteral">&quot;432&quot;</span>,</div>
<div class="line">    limits=(0.0, 3.0),</div>
<div class="line">    ncontour=12,</div>
<div class="line">)</div>
<div class="line">neml2.postprocessing.pretty_plot_pole_figure_odf(</div>
<div class="line">    odf_integrated,</div>
<div class="line">    torch.tensor([1, 1, 1.0], device=device),</div>
<div class="line">    crystal_symmetry=<span class="stringliteral">&quot;432&quot;</span>,</div>
<div class="line">    limits=(0.0, 3.0),</div>
<div class="line">    ncontour=12,</div>
<div class="line">)</div>
</div><!-- fragment --><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/crystal_plasticity/compare_formulations_24_0.png" alt="png" class="inline"/></p>
<p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/crystal_plasticity/compare_formulations_24_1.png" alt="png" class="inline"/></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md156"></a>
Plot some comparisons of the elastic strains</h1>
<p>Extract the elastic strains from each model and plot:</p><ol type="1">
<li>The history of each crystal over time</li>
<li>The average over time</li>
</ol>
<p>The averages are consistent but there are some differences in stress/elastic strain history between crystals when calculated this way.</p>
<div class="fragment"><div class="line">state_history_split = neml2.disassemble_vector(</div>
<div class="line">    <a class="code hl_class" href="classneml2_1_1Tensor.html">neml2.Tensor</a>(results_seperate, 2), model_separate.discrete_equations.slayout</div>
<div class="line">)</div>
<div class="line">state_history_mult = neml2.disassemble_vector(</div>
<div class="line">    <a class="code hl_class" href="classneml2_1_1Tensor.html">neml2.Tensor</a>(results_integrated, 2), model_integrated.discrete_equations.slayout</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">iFp = model_integrated.discrete_equations.smap.index(<span class="stringliteral">&quot;state/Fp&quot;</span>)</div>
<div class="line">Fp_mult = state_history_mult[iFp].<a class="code hl_namespace" href="namespacetorch.html">torch</a>().reshape(F.shape[:-2] + (3, 3))</div>
<div class="line">Fe_mult = F @ torch.linalg.inv(Fp_mult)</div>
<div class="line">U_mult, S_mult, Vh_mult = torch.linalg.svd(Fe_mult)</div>
<div class="line">Re_mult = U_mult @ Vh_mult</div>
<div class="line">Ue_mult = Vh_mult.transpose(-2, -1).conj() @ torch.diag_embed(S_mult, dim1=-2, dim2=-1) @ Vh_mult</div>
<div class="line">E_mult = 0.5 * (Ue_mult.transpose(-2, -1) @ Ue_mult - torch.eye(3, device=device))</div>
<div class="line">ie = model_separate.discrete_equations.smap.index(<span class="stringliteral">&quot;state/elastic_strain&quot;</span>)</div>
<div class="line"> </div>
<div class="line">plt.plot(times[:, 0, 0].cpu(), state_history_split[ie].<a class="code hl_namespace" href="namespacetorch.html">torch</a>()[:, :, 2].cpu(), <span class="stringliteral">&quot;k-&quot;</span>, alpha=0.5)</div>
<div class="line">plt.plot(times[:, 0, 0].cpu(), E_mult[:, :, 2, 2].cpu(), <span class="stringliteral">&quot;r--&quot;</span>, alpha=0.5)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Time&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Elastic strain in the rolling direction&quot;</span>)</div>
<div class="line">plt.legend(</div>
<div class="line">    [</div>
<div class="line">        Line2D([0], [0], color=<span class="stringliteral">&quot;k&quot;</span>, alpha=0.5),</div>
<div class="line">        Line2D([0], [0], color=<span class="stringliteral">&quot;r&quot;</span>, alpha=0.5, linestyle=<span class="stringliteral">&quot;--&quot;</span>),</div>
<div class="line">    ],</div>
<div class="line">    [<span class="stringliteral">&quot;Seperate&quot;</span>, <span class="stringliteral">&quot;Integrated&quot;</span>],</div>
<div class="line">    loc=<span class="stringliteral">&quot;best&quot;</span>,</div>
<div class="line">)</div>
</div><!-- fragment --><pre class="fragment">&lt;matplotlib.legend.Legend at 0x7506a84e67b0&gt;
</pre><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/crystal_plasticity/compare_formulations_26_1.png" alt="png" class="inline"/></p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(3):</div>
<div class="line">    plt.plot(</div>
<div class="line">        times[:, 0, 0].cpu(),</div>
<div class="line">        torch.mean(state_history_split[ie].<a class="code hl_namespace" href="namespacetorch.html">torch</a>()[:, :, i], dim=-1).cpu(),</div>
<div class="line">        <span class="stringliteral">&quot;k-&quot;</span>,</div>
<div class="line">        alpha=0.5,</div>
<div class="line">    )</div>
<div class="line">    plt.plot(times[:, 0, 0].cpu(), torch.mean(E_mult[:, :, i, i], dim=-1).cpu(), <span class="stringliteral">&quot;r--&quot;</span>, alpha=0.5)</div>
<div class="line">plt.xlabel(<span class="stringliteral">&quot;Time&quot;</span>)</div>
<div class="line">plt.ylabel(<span class="stringliteral">&quot;Elastic strain&quot;</span>)</div>
<div class="line">plt.legend(</div>
<div class="line">    [</div>
<div class="line">        Line2D([0], [0], color=<span class="stringliteral">&quot;k&quot;</span>, alpha=0.5),</div>
<div class="line">        Line2D([0], [0], color=<span class="stringliteral">&quot;r&quot;</span>, alpha=0.5, linestyle=<span class="stringliteral">&quot;--&quot;</span>),</div>
<div class="line">    ],</div>
<div class="line">    [<span class="stringliteral">&quot;Seperate&quot;</span>, <span class="stringliteral">&quot;Integrated&quot;</span>],</div>
<div class="line">    loc=<span class="stringliteral">&quot;best&quot;</span>,</div>
<div class="line">)</div>
</div><!-- fragment --><pre class="fragment">&lt;matplotlib.legend.Legend at 0x75050b0b1810&gt;
</pre><p><img src="/home/runner/work/neml2/neml2/build/tutorials/python/examples/crystal_plasticity/compare_formulations_27_1.png" alt="png" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
