<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.12.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NEML2: WorkDispatcher&lt; I, O, Of, Ip, Op &gt; Class Template Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="clipboard.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
window.MathJax = {
  loader: {load: ['[tex]/ams', '[tex]/physics', '[tex]/boldsymbol']},
  tex: {packages: {'[+]': ['ams', 'physics', 'boldsymbol']},
        tags: 'ams'}
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-tabs.js" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
  <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
  <!-- Demo animations -->
  <script type="text/javascript" src="anime.min.js"></script>
  <script type="text/javascript" src="work-dispatcher.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler.js"></script>
  <script type="text/javascript" src="simple-scheduler-demo.js"></script>
  <script type="text/javascript" src="static-hybrid-scheduler-demo.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init();
    DoxygenAwesomeParagraphLink.init();
    DoxygenAwesomeInteractiveToc.init();
    DoxygenAwesomeTabs.init();
    SimpleSchedulerDemo.init();
    StaticHybridSchedulerDemo.init();
  </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectalign">
                <div id="projectname">NEML2<span
                    id="projectnumber">&#160;2.0.0</span>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classneml2_1_1WorkDispatcher.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classneml2_1_1WorkDispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">WorkDispatcher&lt; I, O, Of, Ip, Op &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The work dispatcher who dispatches work to a worker and reduces the results.  
 <a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename I, typename O, typename Of = typename std::vector&lt;O&gt;, typename Ip = typename type_identity&lt;I&gt;::type, typename Op = typename type_identity&lt;O&gt;::type&gt;<br />
class neml2::WorkDispatcher&lt; I, O, Of, Ip, Op &gt;</div><p>The work dispatcher who dispatches work to a worker and reduces the results. </p>
<dl class="section warning"><dt>Warning</dt><dd>The dispatcher is designed to be thread safe, but we are currently seeing some issues when the dispatcher interacts with torch::jit::tracer. We do not recommend using the dispatcher with torch::jit::tracer until the issue is resolved.</dd></dl>
<p>The work dispatcher coordinates with <a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a> and <a class="el" href="classneml2_1_1WorkScheduler.html" title="Scheduler for work dispatching.">WorkScheduler</a> to dispatch work. The work is generated/loaded by the <a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>; the dispatch is scheduled by a <a class="el" href="classneml2_1_1WorkScheduler.html" title="Scheduler for work dispatching.">WorkScheduler</a>; the dispatching loop is managed by the <a class="el" href="classneml2_1_1WorkDispatcher.html" title="The work dispatcher who dispatches work to a worker and reduces the results.">WorkDispatcher</a>.</p>
<p>The dispatcher also takes care of preprocessing, postprocessing, and reducing the work. In general, each work dispatch involves four steps:</p><ol type="1">
<li>Work generation: The work generator generates the next <code>n</code> batches of work.</li>
<li>Preprocessing: The dispatcher preprocesses the work.</li>
<li>Do work: The worker performs the work.</li>
<li>Postprocessing: The dispatcher postprocesses the result.</li>
</ol>
<p>Once all the work has been completed and results have been collected, the dispatcher reduces the results to obtain the final result.</p>
<p>Notes on threading: The dispatcher can run in synchronous or asynchronous mode.</p><ul>
<li>In synchronous mode, the dispatcher runs in the main thread and dispatches work sequentially. No additional threads are created.</li>
<li>In asynchronous mode, the dispatcher creates a thread pool where each thread is continuously monitoring the task queue. The main thread adds work to the task queue, and the threads in the pool pick up the task and execute it. The main thread waits for all the work to complete before reducing the results.</li>
</ul>
<p>Notes on coordination with the scheduler: The dispatcher communicates with the scheduler to schedule work and to notify the scheduler when work has been dispatched and completed.</p><ul>
<li>In synchronous mode, the dispatcher does not notify the scheduler when work has been dispatched (since the work is dispatched sequentially).</li>
<li>In asynchronous mode, the dispatcher notifies the scheduler when work has been dispatched (i.e. a task added to the task queue). When the task is completed, the worker notifies the scheduler about work completion.</li>
</ul>
<p>Notes on thread-device binding: Currently, the implementation assumes that each thread in the thread pool is binded to one device. Based on this assumption, dispatching work to a device is equivalent to dispatching work to a thread, which greatly simplifies the communication between the threads and the task queue. This assumption could be relaxed in the future based on profiling evidence showing that multiple threads dispatching work to the same device has certain advantage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>Input type of the preprocessed work (generated by the generator) </td></tr>
    <tr><td class="paramname">O</td><td>Output type of the result returned by the worker </td></tr>
    <tr><td class="paramname">Of</td><td>Output type of the final result (after reduction) </td></tr>
    <tr><td class="paramname">Ip</td><td>Input type of the work before preprocessing </td></tr>
    <tr><td class="paramname">Op</td><td>Output type of the result after postprocessing </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;<a class="el" href="WorkDispatcher_8h_source.html">WorkDispatcher.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for WorkDispatcher&lt; I, O, Of, Ip, Op &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classneml2_1_1WorkDispatcher__inherit__graph.png" border="0" usemap="#aWorkDispatcher_3_01I_00_01O_00_01Of_00_01Ip_00_01Op_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aWorkDispatcher_3_01I_00_01O_00_01Of_00_01Ip_00_01Op_01_4_inherit__map" id="aWorkDispatcher_3_01I_00_01O_00_01Of_00_01Ip_00_01Op_01_4_inherit__map">
<area shape="rect" title="The work dispatcher who dispatches work to a worker and reduces the results." alt="" coords="5,79,153,119"/>
<area shape="rect" href="classneml2_1_1TracingInterface.html" title=" " alt="" coords="16,5,143,31"/>
<area shape="poly" title=" " alt="" coords="82,44,82,79,77,79,77,44"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1a08465b7e029397b37ffee409958be" id="r_ae1a08465b7e029397b37ffee409958be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1a08465b7e029397b37ffee409958be">WorkDispatcher</a> (<a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;scheduler, bool async, std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;do_work)</td></tr>
<tr class="separator:ae1a08465b7e029397b37ffee409958be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b929c0c59187034ccc1978da6568cc" id="r_af7b929c0c59187034ccc1978da6568cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b929c0c59187034ccc1978da6568cc">WorkDispatcher</a> (<a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;scheduler, bool async, std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;do_work, std::function&lt; O(std::vector&lt; O &gt; &amp;&amp;)&gt; &amp;&amp;reduce)</td></tr>
<tr class="separator:af7b929c0c59187034ccc1978da6568cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810fc127bf632decdc30032759c70cad" id="r_a810fc127bf632decdc30032759c70cad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a810fc127bf632decdc30032759c70cad">WorkDispatcher</a> (<a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;scheduler, bool async, std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;do_work, std::function&lt; Of(std::vector&lt; Op &gt; &amp;&amp;)&gt; &amp;&amp;reduce, std::function&lt; I(Ip &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;preprocess, std::function&lt; Op(O &amp;&amp;)&gt; &amp;&amp;postprocess)</td></tr>
<tr class="separator:a810fc127bf632decdc30032759c70cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ad3091d7c628adf71fe4667627ecdd" id="r_a94ad3091d7c628adf71fe4667627ecdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94ad3091d7c628adf71fe4667627ecdd">WorkDispatcher</a> (<a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;scheduler, bool async, std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;do_work, std::function&lt; Of(std::vector&lt; Op &gt; &amp;&amp;)&gt; &amp;&amp;reduce, std::function&lt; I(Ip &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;preprocess, std::function&lt; Op(O &amp;&amp;)&gt; &amp;&amp;postprocess, std::function&lt; void(<a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;thread_init)</td></tr>
<tr class="separator:a94ad3091d7c628adf71fe4667627ecdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f9fdb587f99cba965f43bed8f77ff0" id="r_ad3f9fdb587f99cba965f43bed8f77ff0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3f9fdb587f99cba965f43bed8f77ff0">WorkDispatcher</a> ()=delete</td></tr>
<tr class="separator:ad3f9fdb587f99cba965f43bed8f77ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f7e9ee1e6490803b17f0065165d6c7" id="r_ac1f7e9ee1e6490803b17f0065165d6c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f7e9ee1e6490803b17f0065165d6c7">WorkDispatcher</a> (<a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac1f7e9ee1e6490803b17f0065165d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5048656ba7bab44f6f0e8f5f8e771aef" id="r_a5048656ba7bab44f6f0e8f5f8e771aef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5048656ba7bab44f6f0e8f5f8e771aef">WorkDispatcher</a> (const <a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp;)=delete</td></tr>
<tr class="separator:a5048656ba7bab44f6f0e8f5f8e771aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918153d66f4c8d36de2ad2752317f80d" id="r_a918153d66f4c8d36de2ad2752317f80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a918153d66f4c8d36de2ad2752317f80d">operator=</a> (<a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a918153d66f4c8d36de2ad2752317f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8d21f3e65a7cc845d5592df6127daf" id="r_a2c8d21f3e65a7cc845d5592df6127daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c8d21f3e65a7cc845d5592df6127daf">operator=</a> (const <a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp;)=delete</td></tr>
<tr class="separator:a2c8d21f3e65a7cc845d5592df6127daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642cb1181c7b2eaa5de38aab62fdb7a1" id="r_a642cb1181c7b2eaa5de38aab62fdb7a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642cb1181c7b2eaa5de38aab62fdb7a1">~WorkDispatcher</a> () override</td></tr>
<tr class="separator:a642cb1181c7b2eaa5de38aab62fdb7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16421ffb002d505d2eb0c31d075b785" id="r_ae16421ffb002d505d2eb0c31d075b785"><td class="memItemLeft" align="right" valign="top">Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae16421ffb002d505d2eb0c31d075b785">run</a> (<a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>&lt; Ip &gt; &amp;)</td></tr>
<tr class="memdesc:ae16421ffb002d505d2eb0c31d075b785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the dispatching loop (calls run_sync or run_async based on the async flag)  <br /></td></tr>
<tr class="separator:ae16421ffb002d505d2eb0c31d075b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classneml2_1_1TracingInterface"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classneml2_1_1TracingInterface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a></td></tr>
<tr class="memitem:a7fb3d77d7ec367449fdefe09b3f153f8 inherit pub_methods_classneml2_1_1TracingInterface" id="r_a7fb3d77d7ec367449fdefe09b3f153f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#a7fb3d77d7ec367449fdefe09b3f153f8">TracingInterface</a> (std::string)</td></tr>
<tr class="separator:a7fb3d77d7ec367449fdefe09b3f153f8 inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b295353d919122293e42e4a2f9fbb7 inherit pub_methods_classneml2_1_1TracingInterface" id="r_a90b295353d919122293e42e4a2f9fbb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#a90b295353d919122293e42e4a2f9fbb7">TracingInterface</a> (const <a class="el" href="classneml2_1_1OptionSet.html">OptionSet</a> &amp;)</td></tr>
<tr class="separator:a90b295353d919122293e42e4a2f9fbb7 inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938f54c230e1f6e91b5f26d7627aa1d inherit pub_methods_classneml2_1_1TracingInterface" id="r_a0938f54c230e1f6e91b5f26d7627aa1d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#a0938f54c230e1f6e91b5f26d7627aa1d">~TracingInterface</a> ()=default</td></tr>
<tr class="separator:a0938f54c230e1f6e91b5f26d7627aa1d inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b8a20bb18f9da4c187a90cc376cfcb inherit pub_methods_classneml2_1_1TracingInterface" id="r_ac3b8a20bb18f9da4c187a90cc376cfcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#ac3b8a20bb18f9da4c187a90cc376cfcb">TracingInterface</a> (const <a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a> &amp;)=default</td></tr>
<tr class="separator:ac3b8a20bb18f9da4c187a90cc376cfcb inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3229f63ddb6e181165e6dba3a848efc inherit pub_methods_classneml2_1_1TracingInterface" id="r_ad3229f63ddb6e181165e6dba3a848efc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#ad3229f63ddb6e181165e6dba3a848efc">TracingInterface</a> (<a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ad3229f63ddb6e181165e6dba3a848efc inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6802ffba1e76ba2615ec09fb7ec09acf inherit pub_methods_classneml2_1_1TracingInterface" id="r_a6802ffba1e76ba2615ec09fb7ec09acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#a6802ffba1e76ba2615ec09fb7ec09acf">operator=</a> (const <a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a> &amp;)=delete</td></tr>
<tr class="separator:a6802ffba1e76ba2615ec09fb7ec09acf inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca147389cb853a83780cbc2665ffe46 inherit pub_methods_classneml2_1_1TracingInterface" id="r_aeca147389cb853a83780cbc2665ffe46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#aeca147389cb853a83780cbc2665ffe46">operator=</a> (<a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aeca147389cb853a83780cbc2665ffe46 inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4df180cf7a33800d82b839ebc0a3d23 inherit pub_methods_classneml2_1_1TracingInterface" id="r_ac4df180cf7a33800d82b839ebc0a3d23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#ac4df180cf7a33800d82b839ebc0a3d23">event_tracing_enabled</a> () const</td></tr>
<tr class="separator:ac4df180cf7a33800d82b839ebc0a3d23 inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13c33836083ea495f2dc2e0017b6c9f inherit pub_methods_classneml2_1_1TracingInterface" id="r_aa13c33836083ea495f2dc2e0017b6c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structneml2_1_1TraceWriter.html">TraceWriter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#aa13c33836083ea495f2dc2e0017b6c9f">event_trace_writer</a> () const</td></tr>
<tr class="memdesc:aa13c33836083ea495f2dc2e0017b6c9f inherit pub_methods_classneml2_1_1TracingInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event trace writer.  <br /></td></tr>
<tr class="separator:aa13c33836083ea495f2dc2e0017b6c9f inherit pub_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a273768174833995d8ad2eb25994d3530" id="r_a273768174833995d8ad2eb25994d3530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a273768174833995d8ad2eb25994d3530">init_thread_pool</a> ()</td></tr>
<tr class="memdesc:a273768174833995d8ad2eb25994d3530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the thread pool.  <br /></td></tr>
<tr class="separator:a273768174833995d8ad2eb25994d3530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b7e6aa55b6ff0cbf97fbbcc2c7ce1" id="r_a844b7e6aa55b6ff0cbf97fbbcc2c7ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a844b7e6aa55b6ff0cbf97fbbcc2c7ce1">thread_pool_main</a> (const <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a> &amp;)</td></tr>
<tr class="memdesc:a844b7e6aa55b6ff0cbf97fbbcc2c7ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool main function.  <br /></td></tr>
<tr class="separator:a844b7e6aa55b6ff0cbf97fbbcc2c7ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf95283dfdfcd3a519a6413977f8db3" id="r_afbf95283dfdfcd3a519a6413977f8db3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf95283dfdfcd3a519a6413977f8db3">should_unlock_thread</a> ()</td></tr>
<tr class="memdesc:afbf95283dfdfcd3a519a6413977f8db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should unlock thread.  <br /></td></tr>
<tr class="separator:afbf95283dfdfcd3a519a6413977f8db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8191943823b50afb4bb1e5e88c4284fd" id="r_a8191943823b50afb4bb1e5e88c4284fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8191943823b50afb4bb1e5e88c4284fd">stop_thread_pool</a> ()</td></tr>
<tr class="memdesc:a8191943823b50afb4bb1e5e88c4284fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread pool.  <br /></td></tr>
<tr class="separator:a8191943823b50afb4bb1e5e88c4284fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a68a01a1c7c22bfbd9f3f6d20e7d5a" id="r_ab3a68a01a1c7c22bfbd9f3f6d20e7d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3a68a01a1c7c22bfbd9f3f6d20e7d5a">validate</a> () const</td></tr>
<tr class="memdesc:ab3a68a01a1c7c22bfbd9f3f6d20e7d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to validate that the dispatcher is properly configured.  <br /></td></tr>
<tr class="separator:ab3a68a01a1c7c22bfbd9f3f6d20e7d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bcabca6d79e2c582147ae3830b2f93" id="r_ac2bcabca6d79e2c582147ae3830b2f93"><td class="memItemLeft" align="right" valign="top">Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2bcabca6d79e2c582147ae3830b2f93">run_sync</a> (<a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>&lt; Ip &gt; &amp;)</td></tr>
<tr class="memdesc:ac2bcabca6d79e2c582147ae3830b2f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the dispatching loop synchronously.  <br /></td></tr>
<tr class="separator:ac2bcabca6d79e2c582147ae3830b2f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502adcc733331ea51e964acf89af3381" id="r_a502adcc733331ea51e964acf89af3381"><td class="memItemLeft" align="right" valign="top">Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a502adcc733331ea51e964acf89af3381">run_async</a> (<a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>&lt; Ip &gt; &amp;)</td></tr>
<tr class="memdesc:a502adcc733331ea51e964acf89af3381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the dispatching loop asynchronously.  <br /></td></tr>
<tr class="separator:a502adcc733331ea51e964acf89af3381"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5eaf770faa0c1e523f3b3e7c5023d8d9" id="r_a5eaf770faa0c1e523f3b3e7c5023d8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eaf770faa0c1e523f3b3e7c5023d8d9">_scheduler</a></td></tr>
<tr class="memdesc:a5eaf770faa0c1e523f3b3e7c5023d8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the work scheduler.  <br /></td></tr>
<tr class="separator:a5eaf770faa0c1e523f3b3e7c5023d8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020cfba915552d91ac4d50272fe2fba1" id="r_a020cfba915552d91ac4d50272fe2fba1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a020cfba915552d91ac4d50272fe2fba1">_devices</a></td></tr>
<tr class="memdesc:a020cfba915552d91ac4d50272fe2fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device pool requested by the scheduler.  <br /></td></tr>
<tr class="separator:a020cfba915552d91ac4d50272fe2fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063fdb8ba2f81ec510ef35a2b828258f" id="r_a063fdb8ba2f81ec510ef35a2b828258f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a063fdb8ba2f81ec510ef35a2b828258f">_async</a></td></tr>
<tr class="memdesc:a063fdb8ba2f81ec510ef35a2b828258f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to enable asynchronous execution.  <br /></td></tr>
<tr class="separator:a063fdb8ba2f81ec510ef35a2b828258f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68bc39060c24f289907bbcbb87512c8" id="r_ad68bc39060c24f289907bbcbb87512c8"><td class="memItemLeft" align="right" valign="top">std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad68bc39060c24f289907bbcbb87512c8">_do_work</a></td></tr>
<tr class="memdesc:ad68bc39060c24f289907bbcbb87512c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform the work and return the result.  <br /></td></tr>
<tr class="separator:ad68bc39060c24f289907bbcbb87512c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ebcc217f962cebcd0d1eda2fd744a9" id="r_ae1ebcc217f962cebcd0d1eda2fd744a9"><td class="memItemLeft" align="right" valign="top">std::function&lt; Of(std::vector&lt; Op &gt; &amp;&amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1ebcc217f962cebcd0d1eda2fd744a9">_reduce</a></td></tr>
<tr class="memdesc:ae1ebcc217f962cebcd0d1eda2fd744a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to reduce the results.  <br /></td></tr>
<tr class="separator:ae1ebcc217f962cebcd0d1eda2fd744a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff0046e6d5181388200e54184b44761" id="r_a5ff0046e6d5181388200e54184b44761"><td class="memItemLeft" align="right" valign="top">std::function&lt; I(Ip &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff0046e6d5181388200e54184b44761">_preprocess</a></td></tr>
<tr class="memdesc:a5ff0046e6d5181388200e54184b44761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to preprocess the work.  <br /></td></tr>
<tr class="separator:a5ff0046e6d5181388200e54184b44761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e798e97457fc0cd2dbd554a4128b92" id="r_aa3e798e97457fc0cd2dbd554a4128b92"><td class="memItemLeft" align="right" valign="top">std::function&lt; Op(O &amp;&amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3e798e97457fc0cd2dbd554a4128b92">_postprocess</a></td></tr>
<tr class="memdesc:aa3e798e97457fc0cd2dbd554a4128b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to postprocess the result.  <br /></td></tr>
<tr class="separator:aa3e798e97457fc0cd2dbd554a4128b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c2d7bd9a6d8ee54fffb7b99fb5acd4" id="r_a24c2d7bd9a6d8ee54fffb7b99fb5acd4"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24c2d7bd9a6d8ee54fffb7b99fb5acd4">_thread_init</a></td></tr>
<tr class="memdesc:a24c2d7bd9a6d8ee54fffb7b99fb5acd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the thread.  <br /></td></tr>
<tr class="separator:a24c2d7bd9a6d8ee54fffb7b99fb5acd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5a5112cef59a4158fef2fd0a4ed48e" id="r_a1e5a5112cef59a4158fef2fd0a4ed48e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Op &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e5a5112cef59a4158fef2fd0a4ed48e">_results</a></td></tr>
<tr class="memdesc:a1e5a5112cef59a4158fef2fd0a4ed48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results to be reduced.  <br /></td></tr>
<tr class="separator:a1e5a5112cef59a4158fef2fd0a4ed48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a72d732d59d56721d8916416702e265be" id="r_a72d732d59d56721d8916416702e265be"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72d732d59d56721d8916416702e265be">_qmutex</a></td></tr>
<tr class="separator:a72d732d59d56721d8916416702e265be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde12639bb0dfa633ee1e59b1c415257" id="r_afde12639bb0dfa633ee1e59b1c415257"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afde12639bb0dfa633ee1e59b1c415257">_thread_condition</a></td></tr>
<tr class="memdesc:afde12639bb0dfa633ee1e59b1c415257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable for the tasks queue.  <br /></td></tr>
<tr class="separator:afde12639bb0dfa633ee1e59b1c415257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084e883de8dae10a26a45bbe7d5921a7" id="r_a084e883de8dae10a26a45bbe7d5921a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a084e883de8dae10a26a45bbe7d5921a7">_stop</a> = false</td></tr>
<tr class="memdesc:a084e883de8dae10a26a45bbe7d5921a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to stop the thread pool.  <br /></td></tr>
<tr class="separator:a084e883de8dae10a26a45bbe7d5921a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036303c47ad490fba8563f014cfa0367" id="r_a036303c47ad490fba8563f014cfa0367"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a036303c47ad490fba8563f014cfa0367">_thread_pool</a></td></tr>
<tr class="separator:a036303c47ad490fba8563f014cfa0367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f341e17bd7a3a63c3b5c82583cef8b4" id="r_a6f341e17bd7a3a63c3b5c82583cef8b4"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>, std::queue&lt; std::function&lt; void()&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f341e17bd7a3a63c3b5c82583cef8b4">_tasks</a></td></tr>
<tr class="memdesc:a6f341e17bd7a3a63c3b5c82583cef8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task queue for the thread pool.  <br /></td></tr>
<tr class="separator:a6f341e17bd7a3a63c3b5c82583cef8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classneml2_1_1TracingInterface"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classneml2_1_1TracingInterface')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classneml2_1_1TracingInterface.html">TracingInterface</a></td></tr>
<tr class="memitem:acec712ff48d4c0884a1362c116f3257a inherit pub_static_methods_classneml2_1_1TracingInterface" id="r_acec712ff48d4c0884a1362c116f3257a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classneml2_1_1OptionSet.html">OptionSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classneml2_1_1TracingInterface.html#acec712ff48d4c0884a1362c116f3257a">expected_options</a> ()</td></tr>
<tr class="separator:acec712ff48d4c0884a1362c116f3257a inherit pub_static_methods_classneml2_1_1TracingInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae1a08465b7e029397b37ffee409958be" name="ae1a08465b7e029397b37ffee409958be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a08465b7e029397b37ffee409958be">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>async</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>do_work</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7b929c0c59187034ccc1978da6568cc" name="af7b929c0c59187034ccc1978da6568cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b929c0c59187034ccc1978da6568cc">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>async</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>do_work</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; O(std::vector&lt; O &gt; &amp;&amp;)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>reduce</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a810fc127bf632decdc30032759c70cad" name="a810fc127bf632decdc30032759c70cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810fc127bf632decdc30032759c70cad">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>async</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>do_work</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Of(std::vector&lt; Op &gt; &amp;&amp;)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>reduce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; I(Ip &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>preprocess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Op(O &amp;&amp;)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>postprocess</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94ad3091d7c628adf71fe4667627ecdd" name="a94ad3091d7c628adf71fe4667627ecdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ad3091d7c628adf71fe4667627ecdd">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>async</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>do_work</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Of(std::vector&lt; Op &gt; &amp;&amp;)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>reduce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; I(Ip &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>preprocess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Op(O &amp;&amp;)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>postprocess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>thread_init</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3f9fdb587f99cba965f43bed8f77ff0" name="ad3f9fdb587f99cba965f43bed8f77ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f9fdb587f99cba965f43bed8f77ff0">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1f7e9ee1e6490803b17f0065165d6c7" name="ac1f7e9ee1e6490803b17f0065165d6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f7e9ee1e6490803b17f0065165d6c7">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a>&lt; I, O, Of, Ip, Op &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5048656ba7bab44f6f0e8f5f8e771aef" name="a5048656ba7bab44f6f0e8f5f8e771aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5048656ba7bab44f6f0e8f5f8e771aef">&#9670;&#160;</a></span>WorkDispatcher() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a>&lt; I, O, Of, Ip, Op &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a642cb1181c7b2eaa5de38aab62fdb7a1" name="a642cb1181c7b2eaa5de38aab62fdb7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642cb1181c7b2eaa5de38aab62fdb7a1">&#9670;&#160;</a></span>~WorkDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a273768174833995d8ad2eb25994d3530" name="a273768174833995d8ad2eb25994d3530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273768174833995d8ad2eb25994d3530">&#9670;&#160;</a></span>init_thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init_thread_pool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the thread pool. </p>

</div>
</div>
<a id="a2c8d21f3e65a7cc845d5592df6127daf" name="a2c8d21f3e65a7cc845d5592df6127daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8d21f3e65a7cc845d5592df6127daf">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a>&lt; I, O, Of, Ip, Op &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a918153d66f4c8d36de2ad2752317f80d" name="a918153d66f4c8d36de2ad2752317f80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918153d66f4c8d36de2ad2752317f80d">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a>&lt; I, O, Of, Ip, Op &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae16421ffb002d505d2eb0c31d075b785" name="ae16421ffb002d505d2eb0c31d075b785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16421ffb002d505d2eb0c31d075b785">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Of run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>&lt; Ip &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the dispatching loop (calls run_sync or run_async based on the async flag) </p>

</div>
</div>
<a id="a502adcc733331ea51e964acf89af3381" name="a502adcc733331ea51e964acf89af3381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502adcc733331ea51e964acf89af3381">&#9670;&#160;</a></span>run_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Of run_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>&lt; Ip &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the dispatching loop asynchronously. </p>

</div>
</div>
<a id="ac2bcabca6d79e2c582147ae3830b2f93" name="ac2bcabca6d79e2c582147ae3830b2f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bcabca6d79e2c582147ae3830b2f93">&#9670;&#160;</a></span>run_sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Of run_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classneml2_1_1WorkGenerator.html">WorkGenerator</a>&lt; Ip &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>generator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the dispatching loop synchronously. </p>

</div>
</div>
<a id="afbf95283dfdfcd3a519a6413977f8db3" name="afbf95283dfdfcd3a519a6413977f8db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf95283dfdfcd3a519a6413977f8db3">&#9670;&#160;</a></span>should_unlock_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool should_unlock_thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should unlock thread. </p>

</div>
</div>
<a id="a8191943823b50afb4bb1e5e88c4284fd" name="a8191943823b50afb4bb1e5e88c4284fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8191943823b50afb4bb1e5e88c4284fd">&#9670;&#160;</a></span>stop_thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stop_thread_pool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the thread pool. </p>

</div>
</div>
<a id="a844b7e6aa55b6ff0cbf97fbbcc2c7ce1" name="a844b7e6aa55b6ff0cbf97fbbcc2c7ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844b7e6aa55b6ff0cbf97fbbcc2c7ce1">&#9670;&#160;</a></span>thread_pool_main()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool_main </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>device</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread pool main function. </p>

</div>
</div>
<a id="ab3a68a01a1c7c22bfbd9f3f6d20e7d5a" name="ab3a68a01a1c7c22bfbd9f3f6d20e7d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a68a01a1c7c22bfbd9f3f6d20e7d5a">&#9670;&#160;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of , typename Ip , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void validate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to validate that the dispatcher is properly configured. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a063fdb8ba2f81ec510ef35a2b828258f" name="a063fdb8ba2f81ec510ef35a2b828258f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063fdb8ba2f81ec510ef35a2b828258f">&#9670;&#160;</a></span>_async</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool _async</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to enable asynchronous execution. </p>

</div>
</div>
<a id="a020cfba915552d91ac4d50272fe2fba1" name="a020cfba915552d91ac4d50272fe2fba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020cfba915552d91ac4d50272fe2fba1">&#9670;&#160;</a></span>_devices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>&gt; _devices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device pool requested by the scheduler. </p>

</div>
</div>
<a id="ad68bc39060c24f289907bbcbb87512c8" name="ad68bc39060c24f289907bbcbb87512c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68bc39060c24f289907bbcbb87512c8">&#9670;&#160;</a></span>_do_work</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;O(I &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; _do_work</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to perform the work and return the result. </p>

</div>
</div>
<a id="aa3e798e97457fc0cd2dbd554a4128b92" name="aa3e798e97457fc0cd2dbd554a4128b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e798e97457fc0cd2dbd554a4128b92">&#9670;&#160;</a></span>_postprocess</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;Op(O &amp;&amp;)&gt; _postprocess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to postprocess the result. </p>

</div>
</div>
<a id="a5ff0046e6d5181388200e54184b44761" name="a5ff0046e6d5181388200e54184b44761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff0046e6d5181388200e54184b44761">&#9670;&#160;</a></span>_preprocess</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;I(Ip &amp;&amp;, <a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; _preprocess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to preprocess the work. </p>

</div>
</div>
<a id="a72d732d59d56721d8916416702e265be" name="a72d732d59d56721d8916416702e265be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d732d59d56721d8916416702e265be">&#9670;&#160;</a></span>_qmutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex _qmutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex for the thread pool to pick up task from the task queue </p>

</div>
</div>
<a id="ae1ebcc217f962cebcd0d1eda2fd744a9" name="ae1ebcc217f962cebcd0d1eda2fd744a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ebcc217f962cebcd0d1eda2fd744a9">&#9670;&#160;</a></span>_reduce</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;Of(std::vector&lt;Op&gt; &amp;&amp;)&gt; _reduce</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to reduce the results. </p>

</div>
</div>
<a id="a1e5a5112cef59a4158fef2fd0a4ed48e" name="a1e5a5112cef59a4158fef2fd0a4ed48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5a5112cef59a4158fef2fd0a4ed48e">&#9670;&#160;</a></span>_results</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Op&gt; _results</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Results to be reduced. </p>

</div>
</div>
<a id="a5eaf770faa0c1e523f3b3e7c5023d8d9" name="a5eaf770faa0c1e523f3b3e7c5023d8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eaf770faa0c1e523f3b3e7c5023d8d9">&#9670;&#160;</a></span>_scheduler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classneml2_1_1WorkScheduler.html">WorkScheduler</a>&amp; _scheduler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the work scheduler. </p>

</div>
</div>
<a id="a084e883de8dae10a26a45bbe7d5921a7" name="a084e883de8dae10a26a45bbe7d5921a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084e883de8dae10a26a45bbe7d5921a7">&#9670;&#160;</a></span>_stop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool _stop = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to stop the thread pool. </p>

</div>
</div>
<a id="a6f341e17bd7a3a63c3b5c82583cef8b4" name="a6f341e17bd7a3a63c3b5c82583cef8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f341e17bd7a3a63c3b5c82583cef8b4">&#9670;&#160;</a></span>_tasks</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>, std::queue&lt;std::function&lt;void()&gt; &gt; &gt; _tasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Task queue for the thread pool. </p>

</div>
</div>
<a id="afde12639bb0dfa633ee1e59b1c415257" name="afde12639bb0dfa633ee1e59b1c415257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde12639bb0dfa633ee1e59b1c415257">&#9670;&#160;</a></span>_thread_condition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable _thread_condition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Condition variable for the tasks queue. </p>

</div>
</div>
<a id="a24c2d7bd9a6d8ee54fffb7b99fb5acd4" name="a24c2d7bd9a6d8ee54fffb7b99fb5acd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c2d7bd9a6d8ee54fffb7b99fb5acd4">&#9670;&#160;</a></span>_thread_init</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(<a class="el" href="namespaceneml2.html#a09235c8815e870c0e839816a881ce30a">Device</a>)&gt; _thread_init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to initialize the thread. </p>

</div>
</div>
<a id="a036303c47ad490fba8563f014cfa0367" name="a036303c47ad490fba8563f014cfa0367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036303c47ad490fba8563f014cfa0367">&#9670;&#160;</a></span>_thread_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename Of  = typename std::vector&lt;O&gt;, typename Ip  = typename type_identity&lt;I&gt;::type, typename Op  = typename type_identity&lt;O&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::thread&gt; _thread_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Thread pool for asynchronous execution TODO: We are currently assuming each thread is responsible for one device. This may not be true/optimal in the future. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceneml2.html">neml2</a></li><li class="navelem"><a class="el" href="classneml2_1_1WorkDispatcher.html">WorkDispatcher</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
